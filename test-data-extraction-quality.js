#!/usr/bin/env node

import fetch from 'node-fetch';
import FormData from 'form-data';
import fs from 'fs';
import path from 'path';

class DataExtractionQualityTest {
    constructor() {
        this.testDocuments = [
            {
                name: 'Nubank_2025-05-24_1751172520674.pdf',
                type: 'Fatura Cart√£o',
                expectedBank: 'Nubank',
                expectedTransactions: '>= 5'
            },
            {
                name: 'Fatura-CPF_1751146806544.PDF',
                type: 'Fatura',
                expectedBank: 'Detectar automaticamente',
                expectedTransactions: '>= 3'
            },
            {
                name: 'Extrato-13-05-2025-a-12-06-2025_1751172520517.pdf',
                type: 'Extrato Banc√°rio',
                expectedBank: 'Banco do Brasil ou similar',
                expectedTransactions: '>= 10'
            },
            {
                name: 'InfinitePay 18-03-2025 a 17-06-2025_1751172372227.pdf',
                type: 'Extrato Fintech',
                expectedBank: 'InfinitePay',
                expectedTransactions: '>= 5'
            },
            {
                name: 'PicPay_Fatura_042025_1751172520655.pdf',
                type: 'Fatura Digital',
                expectedBank: 'PicPay',
                expectedTransactions: '>= 3'
            }
        ];
        
        this.results = [];
        this.cookies = null;
    }

    async login() {
        console.log('üîê Realizando login...');
        const loginResponse = await fetch('http://localhost:5000/api/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username: 'Admin', password: 'admin123' })
        });
        
        if (!loginResponse.ok) {
            throw new Error('Falha no login');
        }
        
        this.cookies = loginResponse.headers.get('set-cookie');
        console.log('‚úÖ Login realizado com sucesso');
    }

    async testDocument(doc) {
        const filePath = path.join('attached_assets', doc.name);
        
        if (!fs.existsSync(filePath)) {
            return {
                document: doc.name,
                status: 'ARQUIVO N√ÉO ENCONTRADO',
                score: 0,
                details: 'Arquivo n√£o existe no sistema'
            };
        }
        
        console.log(`\nüìÑ Testando: ${doc.name} (${doc.type})`);
        
        try {
            // Criar conversa
            const conversationResponse = await fetch('http://localhost:5000/api/conversations', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Cookie': this.cookies 
                },
                body: JSON.stringify({ title: `Teste ${doc.name}` })
            });
            
            const conversation = await conversationResponse.json();
            
            // Upload do documento
            const formData = new FormData();
            formData.append('file', fs.createReadStream(filePath));
            formData.append('conversationId', conversation.id);
            
            const uploadResponse = await fetch('http://localhost:5000/api/upload', {
                method: 'POST',
                headers: { 'Cookie': this.cookies },
                body: formData
            });
            
            if (!uploadResponse.ok) {
                return {
                    document: doc.name,
                    status: 'ERRO NO UPLOAD',
                    score: 0,
                    details: `HTTP ${uploadResponse.status}`
                };
            }
            
            console.log(`  ‚úÖ Upload realizado`);
            
            // Aguardar processamento
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            // Verificar mensagens
            const messagesResponse = await fetch(`http://localhost:5000/api/conversations/${conversation.id}/messages`, {
                headers: { 'Cookie': this.cookies }
            });
            
            const messages = await messagesResponse.json();
            
            // Analisar resultados
            return this.analyzeExtractionQuality(doc, messages);
            
        } catch (error) {
            return {
                document: doc.name,
                status: 'ERRO DE EXECU√á√ÉO',
                score: 0,
                details: error.message
            };
        }
    }

    analyzeExtractionQuality(doc, messages) {
        const analysisMessage = messages.find(m => 
            m.sender === 'assistant' && 
            m.content && 
            m.content.includes('AN√ÅLISE FINANCEIRA')
        );
        
        if (!analysisMessage) {
            return {
                document: doc.name,
                status: 'SEM AN√ÅLISE',
                score: 0,
                details: 'Nenhuma an√°lise financeira foi gerada'
            };
        }
        
        const content = analysisMessage.content;
        let score = 0;
        const details = [];
        
        // Crit√©rio 1: Detec√ß√£o de banco (25 pontos)
        if (content.includes('BANCO DETECTADO') || 
            content.includes(doc.expectedBank) || 
            content.toLowerCase().includes('nubank') ||
            content.toLowerCase().includes('infinitepay') ||
            content.toLowerCase().includes('picpay')) {
            score += 25;
            details.push('‚úÖ Banco detectado corretamente');
        } else {
            details.push('‚ùå Banco n√£o detectado');
        }
        
        // Crit√©rio 2: Extra√ß√£o de transa√ß√µes (30 pontos)
        const transactionCount = this.countTransactions(content);
        if (transactionCount >= 3) {
            score += 30;
            details.push(`‚úÖ ${transactionCount} transa√ß√µes extra√≠das`);
        } else {
            details.push(`‚ùå Apenas ${transactionCount} transa√ß√µes extra√≠das`);
        }
        
        // Crit√©rio 3: Valores monet√°rios (20 pontos)
        const hasValidAmounts = this.hasValidMonetaryValues(content);
        if (hasValidAmounts) {
            score += 20;
            details.push('‚úÖ Valores monet√°rios v√°lidos detectados');
        } else {
            details.push('‚ùå Valores monet√°rios n√£o detectados');
        }
        
        // Crit√©rio 4: Categoriza√ß√£o (15 pontos)
        if (content.includes('cr√©dito') || content.includes('d√©bito') || 
            content.includes('categoria') || content.includes('tipo')) {
            score += 15;
            details.push('‚úÖ Categoriza√ß√£o presente');
        } else {
            details.push('‚ùå Categoriza√ß√£o ausente');
        }
        
        // Crit√©rio 5: An√°lise de risco (10 pontos)
        if (content.includes('risco') || content.includes('score') || 
            content.includes('recomenda')) {
            score += 10;
            details.push('‚úÖ An√°lise de risco presente');
        } else {
            details.push('‚ùå An√°lise de risco ausente');
        }
        
        let status = 'BAIXA QUALIDADE';
        if (score >= 80) status = 'ALTA QUALIDADE';
        else if (score >= 60) status = 'QUALIDADE M√âDIA';
        else if (score >= 40) status = 'QUALIDADE BAIXA';
        
        return {
            document: doc.name,
            type: doc.type,
            status: status,
            score: score,
            transactionCount: transactionCount,
            details: details,
            fullAnalysis: content.substring(0, 200) + '...'
        };
    }

    countTransactions(content) {
        // Contar linhas que parecem transa√ß√µes
        const lines = content.split('\n');
        let count = 0;
        
        for (const line of lines) {
            // Procurar por padr√µes de transa√ß√£o (data + valor + descri√ß√£o)
            if (line.match(/\d{2}\/\d{2}/) && 
                (line.includes('R$') || line.match(/\d+[,\.]\d{2}/))) {
                count++;
            }
        }
        
        // M√©todo alternativo: contar men√ß√µes expl√≠citas
        const explicitCount = (content.match(/transa√ß√£o|opera√ß√£o|lan√ßamento/gi) || []).length;
        
        return Math.max(count, Math.min(explicitCount, 20));
    }

    hasValidMonetaryValues(content) {
        // Procurar por valores monet√°rios brasileiros
        const brazilianCurrency = /R\$\s*\d+[,\.]\d{2}/g;
        const matches = content.match(brazilianCurrency);
        return matches && matches.length >= 2;
    }

    generateQualityReport() {
        console.log('\n' + '='.repeat(80));
        console.log('üìä RELAT√ìRIO DE QUALIDADE DA EXTRA√á√ÉO DE DADOS');
        console.log('='.repeat(80));
        
        const avgScore = this.results.reduce((sum, r) => sum + r.score, 0) / this.results.length;
        const highQuality = this.results.filter(r => r.score >= 80).length;
        const mediumQuality = this.results.filter(r => r.score >= 60 && r.score < 80).length;
        const lowQuality = this.results.filter(r => r.score < 60).length;
        
        console.log(`\nüìà RESUMO GERAL:`);
        console.log(`- Score m√©dio: ${avgScore.toFixed(1)}%`);
        console.log(`- Alta qualidade: ${highQuality}/${this.results.length} documentos`);
        console.log(`- Qualidade m√©dia: ${mediumQuality}/${this.results.length} documentos`);
        console.log(`- Baixa qualidade: ${lowQuality}/${this.results.length} documentos`);
        
        console.log(`\nüìã DETALHES POR DOCUMENTO:`);
        console.log('-'.repeat(80));
        
        this.results.forEach((result, index) => {
            console.log(`\n${index + 1}. ${result.document} (${result.type})`);
            console.log(`   Status: ${result.status} (${result.score}%)`);
            if (result.transactionCount !== undefined) {
                console.log(`   Transa√ß√µes: ${result.transactionCount}`);
            }
            
            if (result.details) {
                result.details.forEach(detail => {
                    console.log(`   ${detail}`);
                });
            }
            
            if (result.fullAnalysis) {
                console.log(`   Pr√©via: ${result.fullAnalysis}`);
            }
        });
        
        console.log('\n' + '='.repeat(80));
        console.log('üéØ CONCLUS√ïES:');
        console.log('='.repeat(80));
        
        if (avgScore >= 75) {
            console.log('‚úÖ SISTEMA DE EXTRA√á√ÉO DE ALTA QUALIDADE');
            console.log('   O sistema demonstra excelente capacidade de extra√ß√£o de dados.');
        } else if (avgScore >= 60) {
            console.log('‚ö†Ô∏è SISTEMA DE EXTRA√á√ÉO DE QUALIDADE M√âDIA');
            console.log('   O sistema funciona mas precisa de melhorias.');
        } else {
            console.log('‚ùå SISTEMA DE EXTRA√á√ÉO PRECISA DE MELHORIAS');
            console.log('   V√°rias √°reas cr√≠ticas precisam ser corrigidas.');
        }
        
        return {
            averageScore: avgScore,
            totalDocuments: this.results.length,
            qualityDistribution: { highQuality, mediumQuality, lowQuality },
            detailedResults: this.results
        };
    }

    async runCompleteTest() {
        try {
            await this.login();
            
            console.log(`\nüß™ Testando qualidade de extra√ß√£o em ${this.testDocuments.length} documentos...`);
            
            for (const doc of this.testDocuments) {
                const result = await this.testDocument(doc);
                this.results.push(result);
                
                console.log(`  Resultado: ${result.status} (${result.score}%)`);
                
                // Aguardar entre testes para n√£o sobrecarregar
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            const report = this.generateQualityReport();
            
            // Salvar relat√≥rio
            fs.writeFileSync('data-extraction-quality-report.json', JSON.stringify(report, null, 2));
            console.log('\nüíæ Relat√≥rio salvo em: data-extraction-quality-report.json');
            
            return report;
            
        } catch (error) {
            console.error('üí• Erro no teste:', error.message);
            return null;
        }
    }
}

// Executar teste
const test = new DataExtractionQualityTest();
test.runCompleteTest().catch(console.error);